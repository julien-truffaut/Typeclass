<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif', 'Helvetica'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz', 'Gill Sans';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono', 'Consolas', 'Courier New'; }
    </style>
  </head>
  <body>
    <textarea id="source">

```tut:invisible

```

class: center, middle

# Typeclass 101: ad hoc polymorphism in scala
Julien Truffaut • `@JulienTruffaut`

???

- notes here

---
# Instructions

Repository is on github `julien-truffaut/Typeclass`

```
git clone https://github.com/julien-truffaut/Typeclass.git

cd Typeclass

sbt clean test
```

???
- all the code in the slides are compiled using tut
- very few dependencies so it should be fast to download and compile

---

# Ad hoc polymorphism?

```tut:book
def plus[A](a1: A, a2: A): A = ???
def plus[A](a1: Int, a2: Int): Int = ???
def plus[A](a1: Long, a2: Long): Long = ???
```

```tut:book
1 + 2
3.2 + 4.0

List(1,2,3).map(_ + 1)
Vector(1,2,3).map(_ + 1)
```

???
- overloading a function
- parametric polymorphism: `def take[A](xs: List[A]): List[A]`

---

# Inheritance: OOP implementation

```tut:silent
trait Input {
  def setLabel(s: String): Input
}
case class Text(label: String, maxLength: Int) extends Input {
  def setLabel(s: String): Input = copy(label = s)
}
case class Select(label: String, options: List[String]) extends Input {
  def setLabel(s: String): Input = copy(label = s)
}

val text = Text("What is your name?", maxLength = 20)
val select = Select("Favorite language?", List("scala", "haskell", "purescript"))
```

```tut:book
text.setLabel("foo")
select.setLabel("foo")
```

---

# Inheritance: OOP implementation

```tut:silent
trait Input {
  def setLabel(s: String): Input
}
case class Text(label: String, maxLength: Int) extends Input {
  def setLabel(s: String): Input = copy(label = s)
}
case class Select(label: String, options: List[String]) extends Input {
  def setLabel(s: String): Input = copy(label = s)
}
```

```tut:fail
def _setLabel[A <: Input](a: A, s: String): A = a.setLabel(s)
```

---

# F-Bounded

```tut:silent
trait Input[A <: Input[A]] {
  def setLabel(s: String): A
}
case class Text(label: String, maxLength: Int) extends Input[Text] {
  def setLabel(s: String): Text = copy(label = s)
}
case class Select(label: String, options: List[String]) extends Input[Select] {
  def setLabel(s: String): Select = copy(label = s)
}

def _setLabel[A <: Input[A]](a: A, s: String): A = a.setLabel(s)
```

```tut:silent
case class Radio(label: String, options: List[String]) extends Input[Text] {
  def setLabel(s: String): Text = Text(s, 10) // WTF
}
```
		   
???
- this technique is called F-bounded polymorphism

---

# Self type

```tut:silent
trait Input[A <: Input[A]] { self: A =>
  def setLabel(s: String): A
}
case class Text(label: String, maxLength: Int) extends Input[Text] {
  def setLabel(s: String): Text = copy(label = s)
}
case class Select(label: String, options: List[String]) extends Input[Select] {
  def setLabel(s: String): Select = copy(label = s)
}

def _setLabel[A <: Input[A]](a: A, s: String): A = a.setLabel(s)
```

```tut:fail
case class Radio(label: String, options: List[String]) extends Input[Text] {
  def setLabel(s: String): Text = Text(s, 10)
}
```

---
# Self type

```tut:silent
abstract class Radio(labe: String, options: List[String]) extends Input[Radio]

case class YesNo(label: String) extends Radio(label, List("Yes", "No")) {
  def setLabel(s: String): YesNo = copy(label = s)
}

case class Color(label: String) extends Radio(label, List("Red", "Blue", "Yellow")) {
  def setLabel(s: String): YesNo = YesNo(label = s) // WTF
}
```

???
- `YesNo` and `Color` are both an `Input[Radio]` 
- at this point, I give up with interitance

---
# A typeclass definition in scala

Typeclasses are not first class construct in scala but they generally require the following components:
  
1. typeclass is encoded as a `trait` with one or more type parameters
2. instances of the typeclasses are encoded as `implicit` values of the `trait`
3. syntax to extend all typeclass methods to types with an instance via an `implicit class`
4. laws or properties to define invariants of the typeclass

???
- Typeclass are not a 1st class construct means they are derived from other constructs 
- encoding is not unique, here I will present the most common one used in (scalaz, cats, argonaut, circe, etc ...) 
---
# Trait and companion object

```tut:silent
trait Label[A] {
  def getLabel(a: A): String
  def setLabel(a: A, s: String): A
}

object Label {
  def apply[A](implicit ev: Label[A]): Label[A] = ev
}		   
```
???
- trait or abstract class
- `apply` method is just a short cut to summon an instance, `Label[Text]` instead of `implicitly[Label[Text]]`
---
# Instances

```tut:silent
implicit val labelText: Label[Text] = new Label[Text] {
  def getLabel(a: Text): String = a.label
  def setLabel(a: Text, s: String): Text = a.copy(label = s)
}
```

Instances should be located in:
- companion object of the typeclass (e.g. `Label`) or		   
- companion object of the type (e.g. `Text`)

```tut:book
val text = Text("What is your name?", maxLength = 20)
		   
implicitly[Label[Text]].getLabel(text)

Label[Text].getLabel(text)
Label[Text].setLabel(text, "foo")
```
		   
---
# Syntax

```tut:silent
implicit class LabelOps[A](a: A)(implicit ev: Label[A]){
  def getLabel: String = ev.getLabel(a)
  def setLabel(s: String): A = ev.setLabel(a, s)
}
```

Implicit class is generally located in the companion of the typeclass (e.g. `Label`)

```tut:book
text.getLabel
text.setLabel("foo")
```

???
- this pattern is often refer to pimp a class
- typeclasses permit retroactive extension, i.e. extending types define somewhere else   

---
# Laws

```tut:silent
import scalaprops.{Gen, Properties}
import scalaprops.Properties.properties
import scalaprops.Property
import scalaprops.Property.forAll		   
import scalaz.std.string._

case class LabelLaws[A](implicit A: Label[A]) {
  
  def getSet(implicit genA: Gen[A]): Property  =
    forAll((a: A) => a.setLabel(a.getLabel) == a)

  def setGet(implicit genA: Gen[A], genString: Gen[String]): Property  =
    forAll((a: A, s: String) => a.setLabel(s).getLabel == s)

  def all(implicit genA: Gen[A], genString: Gen[String]): Properties[String] =
    properties("Label")(
     ("getSet", getSet),
     ("setGet", setGet))
}
```
???
- there are more freedom regarding location of laws, some people like to have it in the same file or same module than the typeclass but it requires to add `Scalacheck` or `scalaprop` to your main dependencies. Other people prefer to define them in a separate module or in test

---
# Laws

```tut:silent
import scalaprops.Scalaprops

object TextTest extends Scalaprops {
  implicit val genString: Gen[String] = Gen.asciiString

  implicit val genText: Gen[Text] = for {
    l <- Gen.asciiString
    i <- Gen.choose(1, 100)
  } yield Text(l, i)
	 
  val label = LabelLaws[Text].all
}		 
```

---
# Typeclass + Instance

```tut:silent
trait Label[A] {
  def getLabel(a: A): String
  def setLabel(a: A, s: String): A
}; object Label {
  def apply[A](implicit ev: Label[A]): Label[A] = ev

  implicit class LabelOps[A](a: A)(implicit ev: Label[A]){
    def getLabel: String = ev.getLabel(a)
    def setLabel(s: String): A = ev.setLabel(a, s)
  }
}

case class Text(label: String, maxLength: Int); object Text {
  implicit val label: Label[Text] = new Label[Text]{
    def getLabel(a: Text): String = a.label
    def setLabel(a: Text, s: String): Text = a.copy(label = s)
  }
}
```

---
# Semigroup exercices

```tut:silent
trait Semigroup[A] {
  def combine(x: A, y: A): A
}
```

1. Implement `SemigroupOps` in `typeclass.syntax.semigroup`
2. Implement associative law in `SemigroupLaws`
3. Implement an instance of `Semigroup` for `String`, `Int`, `List[A]`, `Option[A]` in `typeclass.std`
4. Implement an instance of `Semigroup` for `NonEmptyList[A]` in `typeclass.data`
	 
run tests using: `sbt exercice/test`

???
- `Semigroup[Int]` is not unique, `+` and `*`. Solution: newtype Mult
- same for `String`: `s1 + s2` or `s2 + s1`
- what about `Option`? `First`, `Last`

---
# Instance uniqueness


```tut:silent
implicit val additiveInt: Semigroup[Int] = new Semigroup[Int]{
  def combine(x: Int, y: Int): Int = x + y
}
implicit val multiplicativeInt: Semigroup[Int] = new Semigroup[Int]{
  def combine(x: Int, y: Int): Int = x * y
}
```

```tut:fail
implicitly[Semigroup[Int]]
```
---
# Newtype

```scala
case class Mult(value: Int)
implicit val multSemigroup: Semigroup[Mult] = new Semigroup[Mult]{
  def combine(x: Mult, y: Mult): Mult =
    Mult(x.value * y.value)	 
}

case class First[A](value: Option[A])
case class Last[A](value: Option[A])

implicit def firstSemigroup[A]: Semigroup[First[A]] = ???
implicit def lastSemigroup[A] : Semigroup[Last[A]]  = ???
```

1. Implement a `Semigroup` instance for `First`, `Last` in `typeclass.data`
	 
---
# Semigroup

```tut:invisible
import typeclass.data.{NonEmptyList, First, Last}
```
```tut:silent
import typeclass.syntax.semigroup._
import typeclass.std.int._
import typeclass.std.option._
```

```tut:book
Option(1).combine(Option(2))
First(Option(1)).combine(First(Option(2)))
Last(Option(1)).combine(Last(Option(2)))
```
```tut:fail
"Hello".combine(" World")
```
```tut:silent
import typeclass.std.string._
```

```tut:book
"Hello".combine(" World")
```

???
- for your own data type, instances are in the companion object => no need of extra import

---
# Monoid Exercices

```tut:silent
trait Monoid[A] extends Semigroup[A] {
  def empty: A

  def isEmpty(a: A): Boolean = ???
  def ifEmpty[B](a: A)(t: => B)(f: => B): B = ???
}
```

1. Derive `isEmpty` and `ifEmpty` from `empty`
2. Write `MonoidOps` in `typeclass.syntax.monoid`
3. Implement left identity law in `MonoidLaws`: `empty.combine(a) == a`
4. Implement right identity law in `MonoidLaws`: `a.combine(empty) == a`
5. Implement an instance of `Monoid` for `String`, `Int`, `List[A]`, `Option[A]` in `typeclass.std`
6. Implement an instance of `Monoid` for `NonEmptyList[A]`, `Mult`, `First`, `Last` in `typeclass.data`

???
- `Monoid[NonEmptyList]` is impossible
	
---
# Typeclass for higher kinded type

```scala
scala> :k 1
scala.Int's kind is A

scala> :k String
java.lang.String's kind is A		   

scala> :k Option
scala.Option's kind is F[+A]

scala> :k scala.Function1
scala.Function1's kind is F[-A1,+A2]
```

```tut:silent
trait Semigroup[A]{}
trait Functor[F[_]]{}

new Semigroup[Int]{}
new Functor[List]{}
```

```tut:fail
new Functor[Int]{}
```

---
# Functor Exercices

```tut:silent
trait Functor[F[_]] {
  def map[A, B](fa: F[A])(f: A => B): F[B]

  def void[A](fa: F[A]): F[Unit] = ???
  def as[A, B](fa: F[A], b: B): F[B] = ???
  def lift[A, B](f: A => B): F[A] => F[B] = ???
}
```

1. Derive `void`, `as` and `lift` from `map`
2. Write `FunctorOps` in `typeclass.syntax.functor`
3. Implement map identity law in `FunctorLaws`: `fa.map(id) == fa`
4. Implement map fusion law in `FunctorLaws`: `fa.map(f).map(g) == fa.map(g . f)`
5. Implement an instance of `Functor` for `List`, `Option` in `typeclass.std`
6. Implement an instance of `Functor` for `NonEmptyList` in `typeclass.data`

???
- for `Option` try not to reuse `map`

---
# Validation

```tut:silent
sealed trait Validation[E, A]
case class Success[E, A](value: A) extends Validation[E, A]
case class Failure[E, A](value: E) extends Validation[E, A]

implicit def validationFunctor[E]: Functor[({type λ[a] = Validation[E, a]})#λ] =
  new Functor[({type λ[a] = Validation[E, a]})#λ]{
    def map[A, B](fa: Validation[E, A])(f: A => B): Validation[E, B] = ???
  }

// or with kind-projector
	
implicit def validationFunctor[E]: Functor[Validation[E, ?]] = new Functor[Validation[E, ?]]{
  def map[A, B](fa: Validation[E, A])(f: A => B): Validation[E, B] = ???
}
```

1. Implement an instance of `Functor` for `Validation`

???
- ? comes from kind projector

---
# Applicative

```tut:silent
trait Applicative[F[_]] extends Functor[F]{
  def pure[A](a: A): F[A]
  def ap[A, B](fab: F[A => B], fa: F[A]): F[B]

  def map[A, B](fa: F[A])(f: A => B): F[B] = ???
  def map2[A, B, C](fa: F[A], fb: F[B])(f: (A, B) => C): F[C] = ???
  def *>[A, B](fa: F[A], fb: F[B]): F[B] = ???
  def <*[A, B](fa: F[A], fb: F[B]): F[A] = ???
  def forever[A](fa: F[A]): F[A] = ???
  def tuple2[A, B](fa: F[A], fb: F[B]): F[(A, B)] = ???
  def lift2[A, B, C](f: (A, B) => C): (F[A], F[B]) => F[C] = ???
}
```

???
- `Applicative` is a `Functor`
- `Applicative` has two primitive: `pure` and `ap`
- `ap` looks fairly complited because of `F[A => B]`, in essence `ap` and `map2` are the same	  
- `Applicative` has a default implementation of `map` from `Functor`
	  
---
# Applicative examples

```tut:silent
import typeclass.syntax.applicative._
import typeclass.std.list._

val xs = List(1,5,10)
val ys = List(2,4)
val fs = List[Int => Int](_ + 1, _ * 2, _ - 1)
```

```tut:book
fs.ap(xs)
xs.map2(ys)(_ + _)
xs.tuple2(ys)
```
---
# Applicative examples

```tut:invisible
import typeclass.Applicative
```

```tut:silent
import typeclass.data.{Validation, NonEmptyList}
import typeclass.data.Validation.{successNel, failureNel}
import typeclass.syntax.applicative._

case class Person(name: String, age: Int)

def positive(n: Int): Validation[NonEmptyList[String], Int] =
  if(n <= 0) failureNel(s"$n is not positive") else successNel(n)

def capitalise(s: String): Validation[NonEmptyList[String], String] =
  s.headOption.fold(successNel[String, String](s))(c =>
    if(c == c.toUpper) successNel(s)
    else failureNel(s"$s does not start with an upper case")
  )

def person(name: String, age: Int): Validation[NonEmptyList[String], Person] =
  capitalise(name).map2(positive(age))(Person(_, _))
```

```tut:book
person("John", 24)
person("John", -2)
person("john", 0)
```

---
# Applicative exercices

```tut:silent
trait Applicative[F[_]] extends Functor[F]{
  def pure[A](a: A): F[A]
  def ap[A, B](fab: F[A => B], fa: F[A]): F[B]

  def map[A, B](fa: F[A])(f: A => B): F[B] = ???
  def map2[A, B, C](fa: F[A], fb: F[B])(f: (A, B) => C): F[C] = ???
  def *>[A, B](fa: F[A], fb: F[B]): F[B] = ???
  def <*[A, B](fa: F[A], fb: F[B]): F[A] = ???
  def forever[A](fa: F[A]): F[A] = ???
  def tuple2[A, B](fa: F[A], fb: F[B]): F[(A, B)] = ???
  def lift2[A, B, C](f: (A, B) => C): (F[A], F[B]) => F[C] = ???
}
```

1. Implement derived `Applicative` methods: `map`, `map2`, ...
2. Implement `ApplicativeOps` in `typeclass.syntax.functor`
3. Implement lift function law in `ApplicativeLaws`: `ap(pure f, pure a) == pure f(a)`
4. Implement ap id law in `ApplicativeLaws`: `ap(pure id, fa) == fa`
5. Implement map consistency law in `ApplicativeLaws`
6. Implement an instance of `Applicative` for `List`, `Option` in `typeclass.std`
7. Implement an instance of `Applicative` for `NonEmptyList` and `Validation` in `typeclass.data`

???




---
# ZipStream

```tut:silent
import typeclass.data.ZipStream
	  
val xs = ZipStream(1,5,10)
val ys = ZipStream(2,4)
val fs = ZipStream((_: Int) + 1, (_: Int) * 2, (_: Int) - 1)
```

```tut:book
fs.ap(xs)
xs.map2(ys)(_ + _)
xs.tuple2(ys)
```

1. Create `ZipStream` with such `Applicative` instance
	
---
# Implicits: Type dictionary

```tut:silent
implicit val i: Int = 2 
implicit val l: Long = 3L
```

```tut:book
implicitly[Int]
implicitly[Long]
```

```tut:silent
implicit val i2: Int = 0
```

```tut:fail
implicitly[Int]
```

---
# Implicit parameters

```tut:invisible
import typeclass.Semigroup
```

```tut:silent
def plus3[A](a1: A, a2: A, a3: A)(implicit ev: Semigroup[A]): A =
  ev.combine(ev.combine(a1, a2), a3)

def plus3[A: Semigroup](a1: A, a2: A, a3: A): A =
  Semigroup[A].combine(Semigroup[A].combine(a1, a2), a3)

def plus3[A: Semigroup](a1: A, a2: A, a3: A): A =
  a1.combine(a2).combine(a3)
```
	
```tut:fail
plus3(1L, 2L, 3L)
```

```tut:silent
import typeclass.std.long._
```

```tut:book
plus3(1L, 2L, 3L)
```

---
# Implicit conversion

	
---
# Reduce boiler plate with simulacrum

```tut:silent
import simulacrum._

@typeclass trait Label2[A]{
  def getLabel2(a: A): String
  def setLabel2(a: A, s: String): A
}
		   
implicit val label2Text: Label2[Text] = new Label2[Text] {
  def getLabel2(a: Text): String = a.label
  def setLabel2(a: Text, s: String): Text = a.copy(label = s)
}
```

```tut:invisible
val text = Text.apply("What is your name?", maxLength = 20)
```

```tut:book
import Label2.ops._
text.getLabel2
text.setLabel2("foo")
```

---
class: center, middle

# Thanks!
Code and slides at `julien-truffaut/Typeclass` on GitHub

## Questions?

---

# References

- [tut](https://github.com/tpolecat/tut), [remark.js](https://github.com/gnab/remark), tpolecat [presentation]((https://github.com/tpolecat/cofree/blob/master/tut/slides.html)) I copied from
- [Returning the "Current" Type in Scala](https://tpolecat.github.io/2015/04/29/f-bounds.html) by Rob Norris
- [Type Classes as Objects and Implicits](http://ropas.snu.ac.kr/~bruno/papers/TypeClasses.pdf) by Oliveira, Bruno; Adriaan Moors; Martin Odersky (2010)
















 </textarea>
    <script src="remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
